# This file is executed on every boot (including wake-boot from deepsleep)# Be careful when editing for style here. Micropython is Diet Python. There are# things that are simply not there and are worked around, or that follow# examples directly from the micropython docs.#### Major things to fix:# Post_to_cloud recursion limit can be hit. We need a number of tries, or a new# approach to retries <- This is crudely fixed, but you will lose data if limit# is hit.# There is no way to configure the network ahead of time. End users would have# to edit this file and then flash the board. We have to come up with something# better. Bluetooth-something-or-other comes to mind, but unsure. This may be# the last hurdle we jump. (There is a built-in AP function in the ESP8266. The# board can be BOTH an AP and a...uh...client at the same time, so maybe we# can use that.# Constantsdebounce_ms = 50time_between_heartbeats_in_minutes = 3# Garbage collection <- This was in the file to start, so I left it.import gcgc.collect()import micropythonimport machineimport timeimport socketimport networkimport ubinascii# setup vars <- I haven't learned a more reliable way of doing this yet.pin_flag = Noneirq_enable = Trueflag_queue = []#light = Noneuid = Nonep = Nonepin_num = Noneaddr = Nonehost = Nonepath = Nonestate = Noneint_retries = 0time_at_last_heartbeat = 0# This is for the web based python console. It's helpful for when you have it# plugged into a machine. You need to know the ESP8266 IP address, then visit# http://micropython.org/webrepl/import webreplwebrepl.start()# We need this in case there is a problem in the interrupt handler, otherwise# we won't see any exceptions. More info here:# http://docs.micropython.org/en/latest/pyboard/reference/isr_rules.html#micropython-issuesmicropython.alloc_emergency_exception_buf(100)# The ESP8266 has an LED on it at GPIO 16 (D0). We'll use that to indicate that# we caught switch activity and are uploading the data. Light turns on when# switch is hit, off when data is finished uploading.light = machine.Pin(16, machine.Pin.OUT)# Now let's mess with networking. The ESP8266 actually has two interfaces:# one that can act as an AP and another that can connect to an existing# network. We're not touching the AP right now. That might be the thing we use# to configure wifi.def do_connect():    #import network    global uid    sta_if = network.WLAN(network.STA_IF)    if not sta_if.isconnected():        print('Connecting to network...')        sta_if.active(True)        sta_if.connect('Railroad', '4029816110')        while not sta_if.isconnected():            pass    print('network config:', sta_if.ifconfig())    mac = ubinascii.hexlify(sta_if.config('mac'),':').decode()    uid = mac.replace(":", "")# I added this to break DNS resolution out of the post_to_cloud method. DNS# resolution is slow, almost never works, and it causes a crash. So this method# tries to resolve it, and if it can't it builds the tuple that the socket# wants with a hardcoded IP addressdef setup_http():    global addr    try:        addr = socket.getaddrinfo('http://data.sparkfun.com/', 80)[0][-1]    except OSError:        print("Couldn't resolve address. Hardcoding...")        addr = '54.86.132.254', 80# This method is called by the main loop and handles sending the information to# the cloud. It watches for HTTP responses for 502 or 503 and, if it sees those# it will retry up to 10 times. After 10 times, it will just stop (otherwise# it will crash).# We also have some error handling for an OSError, which I think doesn't# happen here anymore, but...you know...just in case.def post_to_cloud(p):    global uid # <- There HAS to be a better way than using all these globals    global pin_num    global addr    global host    global path    global int_retries    pin_num = str(p)    print("posting")    url = 'http://data.sparkfun.com/input/RMxK6xlqr8CbmMnQAnoJ?private_key=lzEe5EopAVcYAVvWEv7N&id=%s&pin=%s' % (uid, pin_num[4])    _, _, host, path = url.split('/', 3)    try:        so = socket.socket()        so.connect(addr)        print("Socket connected")        so.send(bytes('GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n' % (path, host), 'utf8'))        data = so.recv(12)        so.close()        if data:            result = data.decode("utf-8")            print("result: ", result) #[-9:])            if result[-3:] == "503" or result[-3:] == "502":                if int_retries < 10:                    print("Retrying...")                    int_retries += 1                    post_to_cloud(pin_num)            data = None            result = None    except OSError:        print("Something went wrong posting")    int_retries = 0def heartbeat(curr_time):    global time_at_last_heartbeat    # Send a heartbeat every so often. time.ticks_diff is a uPython thing. If    # there is no coin activity, the beats should come right on time, but if    # there is coin switch activity between beats, it might be delayed by a few    # seconds by other activity in the main_loop. Really, this only matters for    # the logic we have on the web app, so there we just have to wait for a few    # missed beats before sending an alert.    if time.ticks_diff(curr_time, time_at_last_heartbeat) >= \            (time_between_heartbeats_in_minutes * 60000) or \                    time_at_last_heartbeat == 0:        flag_queue.insert(0, '    9')        time_at_last_heartbeat = curr_time# This is our interrupt handler, also called an Interrupt Service Routine (ISR)# It's called when an interrupt happens. The interrupt passes the GPIO pin# number to this method, and we use that to set a var that the main loop looks# for. When the main loop sees that var, it takes over the processing.def irq_handler(p):    global irq_enable    global pin_flag    # We set the irq_enable to False here. The IRQ remains active, but the    # pin_flag = p code doesn't run again until after we debounce the first    # activity and set the irq_enable flag to True in the main_loop.    if irq_enable:        print("IRQ")        irq_enable = False        pin_flag = p# This is the main loop. Things happen here.def main_loop(**kwargs):    global pin_flag    global flag_queue    global state    global debounce_ms    global irq_enable    print("Main_loop started")    switch_active = 0    while True:        light.high() # Resets LED        # This waits 'debounce_ms' before inserting the activity into the flag        # queue. After the debounce loop runs, we reset pin_flag and set        # irq_enable to True, which allows the IRQ handler to set the pin_flag        # again.        # This is very similar to other suggested ways of debouncing w/ uPython        if pin_flag:            while switch_active < debounce_ms:                switch_active += 1                time.sleep_ms(1)            flag_queue.insert(0, pin_flag)            pin_flag = None            irq_enable = True            switch_active = 0            light.low() # Confirms that we caught a coin switch event        if flag_queue:            print(flag_queue)            post_to_cloud(flag_queue.pop())        heartbeat(time.ticks_ms())def init():    # Assigning names to each GPIO used for coin switch interrupts. These pins are hooked directly    # to the transistors on the MC board.    coin1 = machine.Pin(5, machine.Pin.IN, machine.Pin.PULL_UP) #Left    coin2 = machine.Pin(4, machine.Pin.IN, machine.Pin.PULL_UP) #Center    coin3 = machine.Pin(0, machine.Pin.IN, machine.Pin.PULL_UP) # This causes problems. Need to look into how to use GPIOs more    coin4 = machine.Pin(2, machine.Pin.IN, machine.Pin.PULL_UP) # This causes problems    # These are our interrupts. They're set up to watch for the GPIO to rise from low to high    # and has the irq_handler method as the callback. These are super sensitive, so we may need    # to add code or hardware to debounce.    coin1.irq(trigger=coin1.IRQ_RISING, handler=irq_handler)    coin2.irq(trigger=coin2.IRQ_RISING, handler=irq_handler)    coin3.irq(trigger=coin3.IRQ_RISING, handler=irq_handler)    coin4.irq(trigger=coin4.IRQ_RISING, handler=irq_handler)    do_connect()    setup_http()    main_loop()init()# Almost all of this should be moved to main.py at some point. This file is just to set up# all the system stuff.